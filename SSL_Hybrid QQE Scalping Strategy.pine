// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © djodom
//SSL Hybrid + QQE Scalping from Jordan Fray's strategy here: https://docs.google.com/document/d/1lydXkRPncwEBlLzi-8ff88KwM3G229l2V-UUyx5kXBY/edit#


//@version=4
//By Mihkel00
// This script is designed for the NNFX Method, so it is recommended for Daily charts only. 
// Tried to implement a few VP NNFX Rules
// This script has a SSL / Baseline (you can choose between the SSL or MA), a secondary SSL for continiuation trades and a third SSL for exit trades.
// Alerts added for Baseline entries, SSL2 continuations, Exits.
// Baseline has a Keltner Channel setting for "in zone" Gray Candles
// Added "Candle Size > 1 ATR" Diamonds from my old script with the criteria of being within Baseline ATR range.
// Credits
// Strategy causecelebre https://www.tradingview.com/u/causecelebre/
// SSL Channel ErwinBeckers https://www.tradingview.com/u/ErwinBeckers/
// Moving Averages jiehonglim https://www.tradingview.com/u/jiehonglim/
// Moving Averages  everget https://www.tradingview.com/u/everget/
// "Many Moving Averages" script  Fractured https://www.tradingview.com/u/Fractured/
//study("SSL Hybrid", overlay=true, max_bars_back = 4000)
strategy("SSL Hybrid", overlay=true, max_bars_back = 4000, process_orders_on_close= true)
show_Baseline = input(title="Show Baseline", type=input.bool, defval=true)
show_SSL1 = input(title="Show SSL1", type=input.bool, defval=false)
show_atr = input(title="Show ATR bands", type=input.bool, defval=true)
show_ema = input(title="Show EMA", type=input.bool, defval=true)
//ATR
atrlen = input(14, "ATR Period")
mult = input(1, "ATR Multi", step=0.1)
smoothing = input(title="ATR Smoothing", defval="WMA", options=["RMA", "SMA", "EMA", "WMA"])

ma_function(source, atrlen) => 
    if smoothing == "RMA"
        rma(source, atrlen)
    else
        if smoothing == "SMA"
            sma(source, atrlen)
        else
            if smoothing == "EMA"
                ema(source, atrlen)
            else
                wma(source, atrlen)
atr_slen = ma_function(tr(true), atrlen)
////ATR Up/Low Bands
upper_band = atr_slen * mult + close
lower_band = close - atr_slen * mult

////BASELINE / SSL1 / SSL2 / EXIT MOVING AVERAGE VALUES
maType = input(title="SSL1 / Baseline Type", type=input.string, defval="HMA", options=["SMA","EMA","DEMA","TEMA","LSMA","WMA","MF","VAMA","TMA","HMA", "JMA", "Kijun v2", "EDSMA","McGinley"])
len = input(title="SSL1 / Baseline Length", defval=60)

SSL2Type = input(title="SSL2 / Continuation Type", type=input.string, defval="JMA", options=["SMA","EMA","DEMA","TEMA","WMA","MF","VAMA","TMA","HMA", "JMA","McGinley"])
len2 = input(title="SSL 2 Length", defval=5)
//
SSL3Type = input(title="EXIT Type", type=input.string, defval="HMA", options=["DEMA","TEMA","LSMA","VAMA","TMA","HMA","JMA", "Kijun v2", "McGinley", "MF"])
len3 = input(title="EXIT Length", defval=15)
src = input(title="Source", type=input.source, defval=close)

//
tema(src, len) =>
    ema1 = ema(src, len)
    ema2 = ema(ema1, len)
    ema3 = ema(ema2, len)
    (3 * ema1) - (3 * ema2) + ema3
kidiv = input(defval=1,maxval=4,  title="Kijun MOD Divider")

ema200 = ema(src, 200)  //calculate simple ema 200

jurik_phase = input(title="* Jurik (JMA) Only - Phase", type=input.integer, defval=3)
jurik_power = input(title="* Jurik (JMA) Only - Power", type=input.integer, defval=1)
volatility_lookback = input(10, title="* Volatility Adjusted (VAMA) Only - Volatility lookback length")
//MF
beta = input(0.8,minval=0,maxval=1,step=0.1,  title="Modular Filter, General Filter Only - Beta")
feedback = input(false, title="Modular Filter Only - Feedback")
z = input(0.5,title="Modular Filter Only - Feedback Weighting",step=0.1, minval=0, maxval=1)
//EDSMA
ssfLength = input(title="EDSMA - Super Smoother Filter Length", type=input.integer, minval=1, defval=20)
ssfPoles = input(title="EDSMA - Super Smoother Filter Poles", type=input.integer, defval=2, options=[2, 3])

//----

//EDSMA
get2PoleSSF(src, length) =>
    PI = 2 * asin(1)
    arg = sqrt(2) * PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(arg)
    c2 = b1
    c3 = -pow(a1, 2)
    c1 = 1 - c2 - c3
    
    ssf = 0.0
    ssf := c1 * src + c2 * nz(ssf[1]) + c3 * nz(ssf[2])

get3PoleSSF(src, length) =>
    PI = 2 * asin(1)

    arg = PI / length
    a1 = exp(-arg)
    b1 = 2 * a1 * cos(1.738 * arg)
    c1 = pow(a1, 2)

    coef2 = b1 + c1
    coef3 = -(c1 + b1 * c1)
    coef4 = pow(c1, 2)
    coef1 = 1 - coef2 - coef3 - coef4

    ssf = 0.0
    ssf := coef1 * src + coef2 * nz(ssf[1]) + coef3 * nz(ssf[2]) + coef4 * nz(ssf[3])

ma(type, src, len) =>
    float result = 0
    if type=="TMA"
        result := sma(sma(src, ceil(len / 2)), floor(len / 2) + 1)
    if type=="MF"
        ts=0.,b=0.,c=0.,os=0.
        //----
        alpha = 2/(len+1)
        a = feedback ? z*src + (1-z)*nz(ts[1],src) : src
        //----
        b := a > alpha*a+(1-alpha)*nz(b[1],a) ? a : alpha*a+(1-alpha)*nz(b[1],a)
        c := a < alpha*a+(1-alpha)*nz(c[1],a) ? a : alpha*a+(1-alpha)*nz(c[1],a)
        os := a == b ? 1 : a == c ? 0 : os[1]
        //----
        upper = beta*b+(1-beta)*c
        lower = beta*c+(1-beta)*b 
        ts := os*upper+(1-os)*lower
        result := ts
    if type=="LSMA"
        result := linreg(src, len, 0)
    if type=="SMA" // Simple
        result := sma(src, len)
    if type=="EMA" // Exponential
        result := ema(src, len)
    if type=="DEMA" // Double Exponential
        e = ema(src, len)
        result := 2 * e - ema(e, len)
    if type=="TEMA" // Triple Exponential
        e = ema(src, len)
        result := 3 * (e - ema(e, len)) + ema(ema(e, len), len)
    if type=="WMA" // Weighted
        result := wma(src, len)
    if type=="VAMA" // Volatility Adjusted
        /// Copyright © 2019 to present, Joris Duyck (JD)
        mid=ema(src,len)
        dev=src-mid
        vol_up=highest(dev,volatility_lookback)
        vol_down=lowest(dev,volatility_lookback)
        result := mid+avg(vol_up,vol_down)
    if type=="HMA" // Hull
        result := wma(2 * wma(src, len / 2) - wma(src, len), round(sqrt(len)))
    if type=="JMA" // Jurik
        /// Copyright © 2018 Alex Orekhov (everget)
        /// Copyright © 2017 Jurik Research and Consulting.
        phaseRatio = jurik_phase < -100 ? 0.5 : jurik_phase > 100 ? 2.5 : jurik_phase / 100 + 1.5
        beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
        alpha = pow(beta, jurik_power)
        jma = 0.0
        e0 = 0.0
        e0 := (1 - alpha) * src + alpha * nz(e0[1])
        e1 = 0.0
        e1 := (src - e0) * (1 - beta) + beta * nz(e1[1])
        e2 = 0.0
        e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * pow(1 - alpha, 2) + pow(alpha, 2) * nz(e2[1])
        jma := e2 + nz(jma[1])
        result := jma
    if type=="Kijun v2"
        kijun = avg(lowest(len), highest(len))//, (open + close)/2)
        conversionLine = avg(lowest(len/kidiv), highest(len/kidiv))
        delta = (kijun + conversionLine)/2
        result :=delta
    if type=="McGinley"
        mg = 0.0
        mg := na(mg[1]) ? ema(src, len) : mg[1] + (src - mg[1]) / (len * pow(src/mg[1], 4))
        result :=mg
    if type=="EDSMA"
    
        zeros = src - nz(src[2])
        avgZeros = (zeros + zeros[1]) / 2
        
        // Ehlers Super Smoother Filter 
        ssf = ssfPoles == 2
             ? get2PoleSSF(avgZeros, ssfLength)
             : get3PoleSSF(avgZeros, ssfLength)
        
        // Rescale filter in terms of Standard Deviations
        stdev = stdev(ssf, len)
        scaledFilter = stdev != 0
             ? ssf / stdev
             : 0
        
        alpha = 5 * abs(scaledFilter) / len
        
        edsma = 0.0
        edsma := alpha * src + (1 - alpha) * nz(edsma[1])
        result :=  edsma
    result
    
///SSL 1 and SSL2
emaHigh = ma(maType, high, len)
emaLow = ma(maType, low, len)

maHigh = ma(SSL2Type, high, len2)
maLow = ma(SSL2Type, low, len2)

///EXIT
ExitHigh = ma(SSL3Type, high, len3)
ExitLow = ma(SSL3Type, low, len3)

///Keltner Baseline Channel
BBMC = ma(maType, close, len)
useTrueRange = input(true)
multy = input(0.2, step=0.05, title="Base Channel Multiplier")
Keltma = ma(maType, src, len)
range = useTrueRange ? tr : high - low
rangema = ema(range, len)
upperk =Keltma + rangema * multy
lowerk = Keltma - rangema * multy

//Baseline Violation Candle
open_pos =  open*1
close_pos = close*1
difference = abs(close_pos-open_pos)
atr_violation = difference > atr_slen
InRange = upper_band > BBMC and lower_band < BBMC
candlesize_violation = atr_violation and InRange
plotshape(candlesize_violation, color=color.white, size=size.tiny,style=shape.diamond, location=location.top, transp=0,title="Candle Size > 1xATR")


//SSL1 VALUES
Hlv = int(na)
Hlv := close > emaHigh ? 1 : close < emaLow ? -1 : Hlv[1]
sslDown = Hlv < 0 ? emaHigh : emaLow

//SSL2 VALUES
Hlv2 = int(na)
Hlv2 := close > maHigh ? 1 : close < maLow ? -1 : Hlv2[1]
sslDown2 = Hlv2 < 0 ? maHigh : maLow

//EXIT VALUES
Hlv3 = int(na)
Hlv3 := close > ExitHigh ? 1 : close < ExitLow ? -1 : Hlv3[1]
sslExit = Hlv3 < 0 ? ExitHigh : ExitLow
base_cross_Long = crossover(close, sslExit)
base_cross_Short = crossover(sslExit, close)
codiff = base_cross_Long ? 1 : base_cross_Short ? -1 : na 

//COLORS
show_color_bar = input(title="Color Bars", type=input.bool, defval=true)
color_bar = close > upperk ? #00c3ff : close < lowerk ? #ff0062 : color.gray
color_ssl1 = close > sslDown ? #00c3ff : close < sslDown ? #ff0062 : na

//PLOTS
//plotarrow(codiff, colorup=#00c3ff, colordown=#ff0062,title="Exit Arrows", transp=20, maxheight=20, offset=0)
p1 = plot(show_Baseline ? BBMC : na, color=color_bar, linewidth=4,transp=0, title='MA Baseline')
DownPlot = plot( show_SSL1 ? sslDown : na, title="SSL1", linewidth=3, color=color_ssl1, transp=10)
barcolor(show_color_bar ? color_bar : na)
up_channel = plot(show_Baseline ? upperk : na, color=color_bar, title="Baseline Upper Channel")
low_channel = plot(show_Baseline ? lowerk : na, color=color_bar, title="Basiline Lower Channel")
fill(up_channel, low_channel, color=color_bar, transp=90)

////SSL2 Continiuation from ATR
atr_crit = input(0.9, step=0.1, title="Continuation ATR Criteria")
upper_half = atr_slen * atr_crit + close
lower_half = close - atr_slen * atr_crit
buy_inatr =  lower_half < sslDown2
sell_inatr = upper_half > sslDown2
sell_cont = close < BBMC and close < sslDown2
buy_cont = close > BBMC and close > sslDown2
sell_atr = sell_inatr and sell_cont
buy_atr = buy_inatr and buy_cont
atr_fill = buy_atr ? color.green : sell_atr ? color.purple : color.white
LongPlot = plot(sslDown2, title="SSL2", linewidth=2, color=atr_fill, style=plot.style_circles, transp=0)
u = plot(show_atr ? upper_band : na, "+ATR", color=color.white, transp=80)
l = plot(show_atr ? lower_band : na, "-ATR", color=color.white, transp=80)
a = plot(show_ema ? ema200 : na, "EMA200", color=color.yellow, transp=10)



//----------------------------Multi divergence --------------------------------------------
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © LonesomeTheBlue

//Took most of the inputs out here, and made defaults.
lb = 5 //input(5, title="Left Bars", minval=1)
rb = 5 //input(5, title="Right Bars", minval=1)
showhidden = false //input(false, title = "Show Hidden Divergences")
chcut = true //input(true, title = "Check Cut-Through in indicators !")
shownum = true //input(true, title="Show Divergence Number")
showindis = false //input(false, title="Show Indicator Names")
showpivot = false //input(false, title="Show Pivot Points")
chwidth = true //input(true, title = "Change Width by Number of Divergence")
showlimit = 1 //input(1, title="Minimum Number of Divergence", minval = 1, maxval = 11)
calcmacd = true //input(true, title="MACD")
calcmacda = true //input(true, title="MACD Histogram")
calcrsi = true //input(true, title="RSI")
calcstoc = true //input(true, title="Stochastic")
calccci = true //input(true, title="CCI")
calcmom = true //input(true, title="Momentum")
calcobv = true //input(true, title="OBV")
calcdi = true //input(true, title="Diosc")
calcvwmacd = true //input(true, title="VWmacd")
calccmf = true //input(true, title="Chaikin Money Flow")
calcmfi = true //input(true, title="Money Flow Index")

// RSI
rsi = rsi(close, 14)
// MACD
[macd, signal, deltamacd] = macd(close, 12, 26, 9)
// Momentum
moment = mom(close, 10)
// CCI
cci = cci(close, 10)
// OBV

Obv = obv // cum(change(close) > 0 ? volume : change(close) < 0 ? -volume : 0 * volume)
// Stoch
stk = sma(stoch(close, high, low, 14), 3)
// DIOSC
DI = change(high) - (-change(low))
trur = rma(tr, 14)
diosc = fixnan(100 * rma(DI, 14) / trur)
// volume weighted macd
maFast = vwma(close, 12)
maSlow = vwma(close, 26)
vwmacd = maFast - maSlow
// Chaikin money flow
Cmfm = ((close-low) - (high-close)) / (high - low)
Cmfv = Cmfm * volume
cmf = sma(Cmfv, 21) / sma(volume,21)
// Moneyt Flow Index
Mfi = mfi(close, 14)

float top = na
float bot = na
top := pivothigh(lb, rb)
bot := pivotlow(lb, rb)

plotshape(top and showpivot, text="[PH]",  style=shape.labeldown, color=color.white, textcolor=color.black, location=location.abovebar, offset = -rb)
plotshape(bot and showpivot, text="[PL]",  style=shape.labeldown, color=color.white, textcolor=color.black, location=location.belowbar,  offset = -rb)

topc = 0, botc = 0
topc := top ? lb : nz(topc[1]) + 1
botc := bot ? lb : nz(botc[1]) + 1

// Regular Negative /hidden Divergences
newtop = pivothigh(lb, 0) // check only left side
emptyh = true
if not na(newtop) and ((newtop > high[topc] and not showhidden) or (newtop < high[topc] and showhidden))  // there must not close price higher than the line between last PH and current high
    diff = (newtop - high[topc]) / topc
    hline = newtop - diff                   // virtual line to check there is no close price higher than it
    for x = 1 to topc -1
        if close[x] > hline
            emptyh := false
            break
        hline := hline - diff
else
    emptyh := false

// check cut-through in indicators
nocut1(indi, len)=>
    _ret = true
    diff = (indi - nz(indi[len])) / len
    ln = indi - diff
    for x = 1 to len -1
        if nz(indi[x]) > ln
            _ret := false
            break
        ln := ln - diff
    _ret

rsiok = nocut1(rsi, topc)
macdok = nocut1(macd, topc)
deltamacdok = nocut1(deltamacd, topc)
momentok = nocut1(moment, topc)
cciok = nocut1(cci, topc)
obvok = nocut1(obv, topc)
stkok = nocut1(stk, topc)
dioscok = nocut1(diosc, topc)
vwmacdok = nocut1(vwmacd, topc)
cmfok = nocut1(cmf, topc)
mfiok = nocut1(Mfi, topc)

// Regular Negative Divergences
negdivergence = 0
negdivtxt = ""
if emptyh and not na(newtop) and not showhidden
    if calcrsi and rsi[topc] > rsi and (not chcut or rsiok)
        negdivergence += 1
        negdivtxt := "RSI\n"
    if calcmacd and macd[topc] > macd and (not chcut or macdok)
        negdivergence += 1
        negdivtxt := negdivtxt + "MACD\n"
    if calcmacda and deltamacd[topc] > deltamacd and (not chcut or deltamacdok)
        negdivergence += 1
        negdivtxt := negdivtxt + "MACD Hist\n"
    if calcmom and moment[topc] > moment and (not chcut or momentok)
        negdivergence += 1
        negdivtxt := negdivtxt + "Momentum\n"
    if calccci and cci[topc] > cci and (not chcut or cciok)
        negdivergence := negdivergence + 1
        negdivtxt := negdivtxt + "CCI\n"
    if calcobv and Obv[topc] > Obv and (not chcut or obvok)
        negdivergence += 1
        negdivtxt := negdivtxt + "OBV\n"
    if calcstoc and stk[topc] > stk and (not chcut or stkok)
        negdivergence += 1
        negdivtxt := negdivtxt + "Stoch\n"
    if calcdi and diosc[topc] > diosc and (not chcut or dioscok)
        negdivergence += 1
        negdivtxt := negdivtxt + "Diosc\n"
    if calcvwmacd and vwmacd[topc] > vwmacd and (not chcut or vwmacdok)
        negdivergence += 1
        negdivtxt := negdivtxt + "VWMacd\n"
    if calccmf and cmf[topc] > cmf  and (not chcut or cmfok)
        negdivergence += 1
        negdivtxt := negdivtxt + "CMF\n"
    if calcmfi and Mfi[topc] > Mfi  and (not chcut or mfiok)
        negdivergence += 1
        negdivtxt := negdivtxt + "MFI\n"

// negative hidden divergence
hnegdivergence = 0
hnegdivtxt = ""
if emptyh and not na(newtop) and showhidden
    if calcrsi and rsi[topc] < rsi and (not chcut or rsiok)
        hnegdivergence += 1
        hnegdivtxt := "RSI\n"
    if calcmacd and macd[topc] < macd and (not chcut or macdok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "MACD\n"
    if calcmacda and deltamacd[topc] < deltamacd and (not chcut or deltamacdok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "MACD Hist\n"
    if calcmom and moment[topc] < moment and (not chcut or momentok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "Momentum\n"
    if calccci and cci[topc] < cci and (not chcut or cciok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "CCI\n"
    if calcobv and Obv[topc] < Obv and (not chcut or obvok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "OBV\n"
    if calcstoc and stk[topc] < stk and (not chcut or stkok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "Stoch\n"
    if calcdi and diosc[topc] < diosc and (not chcut or dioscok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "Diosc\n"
    if calcvwmacd and vwmacd[topc] < vwmacd and (not chcut or vwmacdok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "VWMacd\n"
    if calccmf and cmf[topc] < cmf and (not chcut or cmfok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "CMF\n"
    if calcmfi and Mfi[topc] < Mfi  and (not chcut or mfiok)
        hnegdivergence += 1
        hnegdivtxt := hnegdivtxt + "MFI\n"

newareah = false
newareah := top ? false : nz(newareah[1], false)
if negdivergence >= showlimit or hnegdivergence >= showlimit
    var line divlh = na
    var label labh = na
    if newareah                             // we remove old line until It reaches new pivot point (like animation ;)
        line.delete(divlh)
        label.delete(labh)
    newwd = not showhidden ?
       (not chwidth ? 2 :
       negdivergence <= 2 ? 2 :
       negdivergence <= 5 ? 3 :
       negdivergence <= 8 ? 4 : 5) :
       (not chwidth ? 2 :
       hnegdivergence <= 2 ? 2 :
       hnegdivergence <= 5 ? 3 :
       hnegdivergence <= 8 ? 4 : 5)
       
    divlh := line.new(bar_index - topc, high[topc], bar_index, high, color = color.red, width = newwd)
    if shownum or showindis
        txt = showindis ? showhidden ? hnegdivtxt : negdivtxt : ""
        txt := txt + (shownum ? showhidden ? tostring(hnegdivergence) : tostring(negdivergence) : "")
        labh := label.new(bar_index, na, text=txt, color= color.red, textcolor = color.white, style= label.style_labeldown, yloc=yloc.abovebar)
    newareah := true 

// Regular / Hidden positive Divergence
newbot = pivotlow(lb, 0) // check only left side
emptyl = true
if not na(newbot) and ((newbot < low[botc] and not showhidden) or   (newbot > low[botc] and showhidden))  // there must not close price lower than the line between last PL and current low
    diff = (newbot - low[botc]) / botc
    lline = newbot - diff                   // virtual line to check there is no close price lower than it
    for x = 1 to botc -1
        if close[x] < lline
            emptyl := false
            break
        lline := lline - diff
else
    emptyl := false

// check cut-through in indicators
nocut2(indi, len)=>
    _ret = true
    diff = (indi - nz(indi[len])) / len
    ln = indi - diff
    for x = 1 to len -1
        if nz(indi[x]) < ln
            _ret := false
            break
        ln := ln - diff
    _ret

rsiok := nocut2(rsi, botc)
macdok := nocut2(macd, botc)
deltamacdok := nocut2(deltamacd, botc)
momentok := nocut2(moment, botc)
cciok := nocut2(cci, botc)
obvok := nocut2(obv, botc)
stkok := nocut2(stk, botc)
dioscok := nocut2(diosc, botc)
vwmacdok := nocut2(vwmacd, botc)
cmfok := nocut2(cmf, botc)
mfiok := nocut2(Mfi, botc)

//positive regular divergence
posdivergence = 0
posdivtxt = ""
if emptyl and not na(newbot) and not showhidden
    if calcrsi and rsi[botc] < rsi and (not chcut or rsiok)
        posdivergence += 1
        posdivtxt := "RSI\n"
    if calcmacd and macd[botc] < macd  and (not chcut or macdok)
        posdivergence += 1
        posdivtxt := posdivtxt + "MACD\n"
    if calcmacda and deltamacd[botc] < deltamacd and (not chcut or deltamacdok)
        posdivergence += 1
        posdivtxt := posdivtxt + "MACD Hist\n"
    if calcmom and moment[botc] < moment and (not chcut or momentok)
        posdivergence += 1
        posdivtxt := posdivtxt + "Momentum\n"
    if calccci and cci[botc] < cci and (not chcut or cciok)
        posdivergence += 1
        posdivtxt := posdivtxt + "CCI\n"
    if calcobv and Obv[botc] < Obv and (not chcut or obvok)
        posdivergence += 1
        posdivtxt := posdivtxt + "OBV\n"
    if calcstoc and stk[botc] < stk and (not chcut or stkok)
        posdivergence += 1
        posdivtxt := posdivtxt + "Stoch\n"
    if calcdi and diosc[botc] < diosc and (not chcut or dioscok)
        posdivergence += 1
        posdivtxt := posdivtxt + "Diosc\n"
    if calcvwmacd and vwmacd[botc] < vwmacd and (not chcut or vwmacdok)
        posdivergence += 1
        posdivtxt := posdivtxt + "VWMacd\n"
    if calccmf and cmf[botc] < cmf and (not chcut or cmfok)
        posdivergence += 1
        posdivtxt := posdivtxt + "CMF\n"
    if calcmfi and Mfi[botc] < Mfi and (not chcut or mfiok)
        posdivergence += 1
        posdivtxt := posdivtxt + "MFI\n"

// Hidden Positive Divergences
hposdivergence = 0
hposdivtxt = ""
if emptyl and not na(newbot) and showhidden
    if calcrsi and rsi[botc] > rsi and (not chcut or rsiok)
        hposdivergence += 1
        hposdivtxt := "RSI\n"
    if calcmacd and macd[botc] > macd  and (not chcut or macdok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "MACD\n"
    if calcmacda and deltamacd[botc] > deltamacd and (not chcut or deltamacdok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "MACD Hist\n"
    if calcmom and moment[botc] > moment and (not chcut or momentok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "Momentum\n"
    if calccci and cci[botc] > cci and (not chcut or cciok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "CCI\n"
    if calcobv and Obv[botc] > Obv and (not chcut or obvok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "OBV\n"
    if calcstoc and stk[botc] > stk and (not chcut or stkok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "Stoch\n"
    if calcdi and diosc[botc] > diosc and (not chcut or dioscok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "Diosc\n"
    if calcvwmacd and vwmacd[botc] > vwmacd and (not chcut or vwmacdok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "VWMacd\n"
    if calccmf and cmf[botc] > cmf and (not chcut or cmfok)
        hposdivergence += 1
        hposdivtxt := hnegdivtxt + "CMF\n"
    if calcmfi and Mfi[botc] > Mfi and (not chcut or mfiok)
        hposdivergence += 1
        hposdivtxt := hposdivtxt + "MFI\n"

newareal = false
newareal := bot ? false : nz(newareal[1], false)
if posdivergence >= showlimit or hposdivergence >= showlimit
    var line divl = na
    var label lab = na
    if newareal                             // we remove old line until It reaches new pivot point (like animation ;)
        line.delete(divl)
        label.delete(lab)
    newwd = not showhidden ?
       (not chwidth ? 2 :
       posdivergence <= 2 ? 2 :
       posdivergence <= 5 ? 3 :
       posdivergence <= 8 ? 4 : 5) :
       (not chwidth ? 2 :
       hposdivergence <= 2 ? 2 :
       hposdivergence <= 5 ? 3 :
       hposdivergence <= 8 ? 4 : 5)
       
    divl := line.new(bar_index - botc, low[botc], bar_index, low, color = color.lime, width = newwd)
    if shownum or showindis
        txt = showindis ? showhidden ? hposdivtxt : posdivtxt : ""
        txt := txt + (shownum ? showhidden ? tostring(hposdivergence) : tostring(posdivergence) : "")
        lab := label.new(bar_index, na, text=txt, color= color.lime, textcolor = color.black, style = label.style_labelup, yloc=yloc.belowbar)
    newareal := true
 //----------------------QQE MOD-------------------------------------
 //By Glaz, Modified
//
//study("QQE MOD")
RSI_Period = 6 //input(6, title='RSI Length')
SF = 5 //input(5, title='RSI Smoothing')
QQE = 3 //input(3, title='Fast QQE Factor')
ThreshHold = 3 //input(3, title="Thresh-hold")
//

src_qqe = close //input(close, title="RSI Source")
//

//
Wilders_Period = RSI_Period * 2 - 1


Rsi = rsi(src_qqe, RSI_Period)
RsiMa = ema(Rsi, SF)
AtrRsi = abs(RsiMa[1] - RsiMa)
MaAtrRsi = ema(AtrRsi, Wilders_Period)
dar = ema(MaAtrRsi, Wilders_Period) * QQE

longband = 0.0
shortband = 0.0
trend = 0

DeltaFastAtrRsi = dar
RSIndex = RsiMa
newshortband = RSIndex + DeltaFastAtrRsi
newlongband = RSIndex - DeltaFastAtrRsi
longband := RSIndex[1] > longband[1] and RSIndex > longband[1] ? 
   max(longband[1], newlongband) : newlongband
shortband := RSIndex[1] < shortband[1] and RSIndex < shortband[1] ? 
   min(shortband[1], newshortband) : newshortband
cross_1 = cross(longband[1], RSIndex)
trend := cross(RSIndex, shortband[1]) ? 1 : cross_1 ? -1 : nz(trend[1], 1)
FastAtrRsiTL = trend == 1 ? longband : shortband
////////////////////


length = input(50, minval=1, title="Bollinger Length")
mult_qqe = input(0.35, minval=0.001, maxval=5, step=0.1, title="BB Multiplier")
basis = sma(FastAtrRsiTL - 50, length)
dev = mult_qqe * stdev(FastAtrRsiTL - 50, length)
upper = basis + dev
lower = basis - dev
color_bar_qqe = RsiMa - 50 > upper ? #00c3ff : RsiMa - 50 < lower ? #ff0062 : color.gray


//
// Zero cross
QQEzlong = 0
QQEzlong := nz(QQEzlong[1])
QQEzshort = 0
QQEzshort := nz(QQEzshort[1])
QQEzlong := RSIndex >= 50 ? QQEzlong + 1 : 0
QQEzshort := RSIndex < 50 ? QQEzshort + 1 : 0
//  

//Zero = hline(0, color=color.white, linestyle=hline.style_dotted, linewidth=1)

////////////////////////////////////////////////////////////////

RSI_Period2 = input(6, title='RSI Length')
SF2 = input(5, title='RSI Smoothing')
QQE2 = input(1.61, title='Fast QQE2 Factor')
ThreshHold2 = input(3, title="Thresh-hold")

src_qqe2 = input(close, title="RSI Source")
//

//
Wilders_Period2 = RSI_Period2 * 2 - 1


Rsi2 = rsi(src_qqe2, RSI_Period2)
RsiMa2 = ema(Rsi2, SF2)
AtrRsi2 = abs(RsiMa2[1] - RsiMa2)
MaAtrRsi2 = ema(AtrRsi2, Wilders_Period2)
dar2 = ema(MaAtrRsi2, Wilders_Period2) * QQE2
longband2 = 0.0
shortband2 = 0.0
trend2 = 0

DeltaFastAtrRsi2 = dar2
RSIndex2 = RsiMa2
newshortband2 = RSIndex2 + DeltaFastAtrRsi2
newlongband2 = RSIndex2 - DeltaFastAtrRsi2
longband2 := RSIndex2[1] > longband2[1] and RSIndex2 > longband2[1] ? 
   max(longband2[1], newlongband2) : newlongband2
shortband2 := RSIndex2[1] < shortband2[1] and RSIndex2 < shortband2[1] ? 
   min(shortband2[1], newshortband2) : newshortband2
cross_2 = cross(longband2[1], RSIndex2)
trend2 := cross(RSIndex2, shortband2[1]) ? 1 : cross_2 ? -1 : nz(trend2[1], 1)
FastAtrRsi2TL = trend2 == 1 ? longband2 : shortband2


//
// Zero cross
QQE2zlong = 0
QQE2zlong := nz(QQE2zlong[1])
QQE2zshort = 0
QQE2zshort := nz(QQE2zshort[1])
QQE2zlong := RSIndex2 >= 50 ? QQE2zlong + 1 : 0
QQE2zshort := RSIndex2 < 50 ? QQE2zshort + 1 : 0
//  

hcolor2 = RsiMa2 - 50 > ThreshHold2 ? color.silver :
   RsiMa2 - 50 < 0 - ThreshHold2 ? color.silver : na
//plot(FastAtrRsi2TL - 50, title='QQE Line', color=color.white, transp=0, linewidth=2)
//plot(RsiMa2 - 50, color=hcolor2, transp=50, title='Histo2', style=plot.style_columns)

Greenbar1 = RsiMa2 - 50 > ThreshHold2
Greenbar2 = RsiMa - 50 > upper

Redbar1 = RsiMa2 - 50 < 0 - ThreshHold2
Redbar2 = RsiMa - 50 < lower

greenbar = Greenbar1 and Greenbar2
redbar = Redbar1 and Redbar2
graybar = not (greenbar or redbar)
//plot(Greenbar1 and Greenbar2 == 1 ? RsiMa2 - 50 : na, title="QQE Up", style=plot.style_columns, color=#00c3ff, transp=0)
//plot(Redbar1 and Redbar2 == 1 ? RsiMa2 - 50 : na, title="QQE Down", style=plot.style_columns, color=#ff0062, transp=0)

 //Jordan's conditions from https://docs.google.com/document/d/1lydXkRPncwEBlLzi-8ff88KwM3G229l2V-UUyx5kXBY/edit#
 //LONG CONDITIONS
    //1) No bearish divergence score of 2 or more
    //2) Price is above the 200 EMA
    //3) Candle is green
    //4) Candle has a green arrow under it (SSL)
    //5) Candle is no more than a 1% increase from previous candle
    //6) QQE Mod bar is green or absent
    //7) Exception: gray bars with no red bar to the left is okay. 
    
    // Set stop Loss below the green candle (including wick)
    // Move stop loss to break even after target 1 is reached.
    // Move stop loss up previous target level as each new target level is reached.
    // Take profit by being stopped out at the previous target level. 
    // Exception: If QQE momentum score is above 25, hold trade, monitor volume, and take profit when you think you should instead of moving up the SL in 1:1 intervals. When momentum is high and continues to hold, it can be good to let it run with a wider stop loss at breakeven. 

//1: No bearish divergence score of 2 or more   
longcond_1= hposdivergence < 2

//2: Price > 200 EMA
longcond_2 = close > ema200

//3: Candle is green
longcond_3= open < close

//4: Candle has green arrow under it (SSL)
longcond_4 = base_cross_Long 

//5: Candle is no more than 1% increas from previous candle
          //current increase - last increase divided by last increase less than or equal to 1%
longcond_5=  ((close - open) - (close[1] - open[1]))/(close[1] - open[1]) <= 0.01

//6: QQE Mod bar is green or absent
longcond_6= greenbar or (graybar and greenbar[1])

longCondition = longcond_1 and longcond_2 and longcond_3 and longcond_4 and longcond_5 and longcond_6

//1: No bullish divergence score of 2 or more
shortcond_1= hnegdivergence < 2

//2: Price is below the 200 EMA
shortcond_2 = close < ema200

//3: Candle is red or absent
shortcond_3= close <= open

//4: Candle has a red arrow over it
shortcond_4 = base_cross_Short

//5: Candle is no more than a 1% drop from previous candle
shortcond_5=  ((open - close) - (open[1] - close[1]))/(open[1] - close[1]) <= 0.01

//6: QQE Mod is red
shortcond_6= redbar or (graybar and redbar[1])

shortCondition = shortcond_1 and shortcond_2 and shortcond_3 and shortcond_4 and shortcond_5 and shortcond_6

entry_exit_arrow = longCondition ? 2 : shortCondition ? -2 : na 
plotarrow(entry_exit_arrow, colorup=color.green, colordown=color.purple,title="Strategy entry arrows", transp=0, maxheight=20, offset=0)

strategy.entry("LONG", strategy.long, when=longCondition)
strategy.entry("SHORT", strategy.short, when=shortCondition)

//
// The Fixed Percent Stop Loss Code
// User Options to Change Inputs (%)
stopPer = input(0.5, title='Stop Loss %', type=input.float) / 100
takePer = input(1.0, title='Take Profit %', type=input.float) / 100

// Determine where you've entered and in what direction
longStop = strategy.position_avg_price * (1 - stopPer)
shortStop = strategy.position_avg_price * (1 + stopPer)
shortTake = strategy.position_avg_price * (1 - takePer)
longTake = strategy.position_avg_price * (1 + takePer)

if strategy.position_size > 0 
    strategy.exit(id="Close Long", stop=longStop, limit=longTake)
if strategy.position_size < 0 
    strategy.exit(id="Close Short", stop=shortStop, limit=shortTake)


//ALERTS
//alertcondition(crossoveexxitr(close, sslDown), title='SSL Cross Alert', message='SSL1 has crossed.')
//alertcondition(crossover(close, sslDown2), title='SSL2 Cross Alert', message='SSL2 has crossed.')
//alertcondition(sell_atr, title='Sell Continuation', message='Sell Continuation.')
// alertcondition(buy_atr, title='Buy Continuation', message='Buy Continuation.')
// alertcondition(crossover(close, sslExit), title='Exit Sell', message='Exit Sell Alert.')
// alertcondition(crossover(sslExit, close), title='Exit Buy', message='Exit Buy Alert.')
// alertcondition(crossover(close, upperk ), title='Baseline Buy Entry', message='Base Buy Alert.')
// alertcondition(crossover(lowerk, close ), title='Baseline Sell Entry', message='Base Sell Alert.')